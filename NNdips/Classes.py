# -*- coding: utf-8 -*-
"""
Created on Sat Jun  2 18:50:13 2018

@author: Praia
Questions? peer.breier@tum.de
"""
# Classes

# imports
# ======================
import tkinter as tk
from tkinter import filedialog
import numpy as np
from MainGUI import *
import pickle
import Functions
from NNfrontEnd import CNN, TrainData
import os
import fitz
import time  # for titles
from PIL import Image


class GUI:
    """
    Data container for main application.
    * Plans are stored in 'planList' attribute as List of 'PlanData' (cf. classes.py)
    * For each Plan a unique identifier 'PlanID' is generated internally
    * The 'displayedPlan' attribute stores the list-position (integer) of the currently displayed plan
    * Image data for buttons and listboxes are stored in 'ico'
    * The list of Symbols is generated by reading the names of the subfolders of '/CNNs'
    """

    data = NONE  # Registrar

    def __init__(self, root):
        GUI.data = self  # register self
        self.root = root

        # ==== Attributes ====
        self.planList = []
        self.planIDmax = 'P000'
        self.NoPlans = 0
        self.displayedPlan = -1

        self.btnState = {}
        self.btn_size = 64

        self.symDirs = os.listdir('.\CNNs')
        self.activeSym = [self.symDirs[0]]

        self.ico = Ico(self.symDirs)

        self.select_flag = 0
        self.select_folder = ''

    # todo: add 'change button state' functionality
    def addPlan(self, upType):
        """
        Creates filedialog to initiate upload of plan data. Each selected plan is stored in its own 'planData' instance
        and the PlanListBox is updated.
        :param upType: Should be 'f' for single or multi file upload, 'd' for folder upload.
        :return:
        """
        if upType == 'f':
            fTypes = [("supported files", ("*.tif", "*.jpg", "*.png", "*.pdf")), ("tif files", "*.tif"),
                      ("jpeg files", "*.jpg"), ("png files", "*.png"), ("pdf files", "*.pdf")]
            file_list = filedialog.askopenfilenames(title='Pick one or more files', initialdir=str(os.getcwd()),
                                                    filetypes=fTypes)

        elif upType == 'd':
            folder = filedialog.askdirectory(title='Pick a folder', initialdir=str(os.getcwd()))
            if folder == '':  # nothing happens
                return
            file_list = [folder + '/' + file for file in os.listdir(folder)]

        else:
            return

        for file in file_list:
            # check if already uploaded
            if next((True for x in self.planList if x.fileLocation == file), False):
                print(file, ' is already uploaded')
                continue

            plan = Classes.PlanData()
            plan.fileLocation = file
            plan.planImage, plan.rotated, plan.orgDpi = Functions.read_file(file)
            if plan.planImage is []:
                continue

            self.planIDmax = plan.planID = Functions.countID(self.planIDmax)
            self.planList.append(plan)
            vals = (self.planIDmax, str(plan.scanned), str(0))
            ListBox.objs['wbPlan'].insert('', 'end', iid=plan.planID, values=vals, tag=self.planIDmax)
            ListBox.objs['exPlan'].insert('', 'end', iid=plan.planID, values=vals, tag=self.planIDmax)

            if file is file_list[0]:
                self.displayedPlan = self.planList.index(plan)

        self.updateCanv()

    def changePlan(self, op):
        """
        Changes 'displayedPlan' by value of op and calls updateCanv() to display new plan
        :param op: Should be either 1 (next plan) or -1 (previous plan).
        :return:
        """
        pMax = len(self.planList)
        temp = self.displayedPlan + op
        if temp < 0:
            self.displayedPlan = pMax - 1
        elif temp >= pMax:
            self.displayedPlan = 0
        else:
            self.displayedPlan = temp

        self.updateCanv()

    def rotatePlan(self):
        """
        Rotates 'displayedPlan' by 90° to the left and calls updateCanv() to display new plan
        Remember: The plan is stored as an image array.
        :return:
        """
        self.planList[self.displayedPlan].rotateImage()
        self.updateCanv()

    def deletePlan(self):
        """
        Removes currently displayed plan from 'planList' as well as any ListBox and calls updateCanv() to update
        all canvases and ListBoxes.
        :return:
        """
        ListBox.objs['wbPlan'].delete(self.planList[self.displayedPlan].planID)
        ListBox.objs['exPlan'].delete(self.planList[self.displayedPlan].planID)

        del self.planList[self.displayedPlan]
        if self.displayedPlan >= len(self.planList):
            self.displayedPlan = 0
        self.updateCanv()

    def updateCanv(self):
        """
        Calls showSelf() method of 'PlanData' class to display currently selected plan ('displayedPlan' attribute) and
        updates all relevant widgets. Also calls updateRes() to display any results in the newly displayed plan. If
        there are no plans loaded (anymore) it deletes all images from all canvases.
        :return:
        """
        UploadTools.obj.countmodule(self.displayedPlan, len(self.planList))
        if len(self.planList) != 0:
            iid = self.planList[self.displayedPlan].showSelf()
            ListBox.objs['wbPlan'].selection_set(iid)
            ListBox.objs['wbResult'].updateSelf(self.planList[self.displayedPlan].results)

            self.updateRes()
        else:
            NNdipsCanv.clearAll()

    def updateRes(self, op=0):
        """
        Calls showResult() method of 'PlanData' class to display any results of the currently displayed plan and updates
        all relevant widgets. If there are no results (rMax == 0) it deletes the result image and crosshair.
        :param op: Optional, should be either 1 (next result), -1 (previous result), 'del' (delete result) or resultID.
        :return:
        """
        disp, rMax = self.planList[self.displayedPlan].changeRes(op)
        ResultTools.obj.countmodule(disp, rMax)
        ListBox.objs['wbResult'].focus_set()

        if op == 'del':
            ListBox.objs['wbResult'].updateSelf(self.planList[self.displayedPlan].results)
            ListBox.objs['wbPlan'].set(self.planList[self.displayedPlan].planID, 'Hits', rMax)
            ListBox.objs['exSymbol'].updateSelf(self.planList[self.displayedPlan].results)

        if rMax > 0:
            iid = self.planList[self.displayedPlan].showResult()
            ListBox.objs['wbResult'].focus('')
            ListBox.objs['wbResult'].see(iid)  # See is for the treeview, to focus on a symbol
            ListBox.objs['wbResult'].selection_set(iid)

        else:
            NNdipsCanv.canvs['wbResult'].delete("IMG")  # result image
            NNdipsCanv.canvs['wbPlan'].delete('Line')  # crosshairs

    def scanPlan(self, plans):
        """
        Scans all plans stored in Application class attribute 'planList' for all active Symbols with the respective
        CNNs. Updates the resultListBox and displays the found results for the active plan.
        :return:
        """
        overallGoal = len(plans) * len(self.activeSym)
        for plan in plans:
            for sym in self.activeSym:
                if sym in plan.scanned:
                    overallGoal -= 1

        pBar = progressWindow(overallGoal, 'Scanning plan(s)...')
        for plan in plans:
            for sym in self.activeSym:
                if sym not in plan.scanned:  # todo: else Messagebox 'rescan'
                    CNN(plan, sym, pBar)

                    ListBox.objs['wbPlan'].set(plan.planID, 'scanned', str(plan.scanned))
                    ListBox.objs['exPlan'].set(plan.planID, 'scanned', str(plan.scanned))

                    ListBox.objs['wbPlan'].set(plan.planID, 'Hits', str(len(plan.results)))

                    self.root.update()

        pBar.destroy()
        ListBox.objs['wbResult'].updateSelf(self.planList[self.displayedPlan].results)

        self.updateRes()

    # todo: avoid saving complete PlanData, maybe just fileLocation and flags
    def saveData(self):
        """
        Saves project data in specified file
        :return:
        """
        filename = filedialog.asksaveasfilename(initialdir=(str(os.getcwd()) + "\Projects"), title="Save as...",
                                                filetypes=[("NNdips Project", "*.nnprj")], defaultextension=".nnprj")

        with open(filename, "wb") as f:
            pickle.dump((self.planList, self.planIDmax, self.NoPlans, self.displayedPlan), f)

    def loadData(self):
        """
        Reads project file and restores saved project data to 'Application' class
        :return:
        """
        self.planList = []
        filename = filedialog.askopenfilename(title="Load Project...", initialdir=(str(os.getcwd()) + "\Projects"),
                                              filetypes=[("NNDips Project", "*.nnprj")], defaultextension=".nnprj")

        with open(filename, "rb") as f:
            self.planList, self.planIDmax, self.NoPlans, self.displayedPlan = pickle.load(f)

        self.updateCanv()


# todo: catch errors
# ================= GENERAL ===============
class PlanData:
    """
    Container for all relevant plan data.
    * 'planImage' stores Image as binary numpy array.
    * 'fileLocation' stores file location as string.
    * 'results' stores CNN results as list.
    * 'scanned' stores symbol names that were already scanned in this plan.
    * 'planID' stores internally generated unique identifier
    * 'displayedResult' stores list-position (integer) of currently displayed result
    """
    def __init__(self):
        self.planImage = NONE
        self.resultImage = NONE
        self.fileLocation = ''
        self.rotated = 0
        self.results = []
        self.scanned = []
        self.orgDpi = 0
        self.planID = ''
        self.displayedResult = 0

    def changeRes(self, op):
        """
        Modifies 'displayedResult' value by op and stores result snapshot in NNdipsCanvas class attribute.
        :param op: Should be either 1 (next result), -1 (previous result), 'del' (delete result) or resultID.
        :return: 'displayedResult' and rMax (Number of results)
        """
        rMax = len(self.results)
        if op == 'del':
            del self.results[self.displayedResult]
            rMax -= 1
            if self.displayedResult >= rMax:
                self.displayedResult = 0
        elif type(op) == str:
            disp = [i for i, item in enumerate(self.results)
                    if item[0] == op[0:4] and item[1] == int(op[5:])]
            self.displayedResult = disp[0]
        else:
            temp = self.displayedResult + op
            if temp < 0:
                self.displayedResult = rMax - 1
            elif temp >= rMax:
                self.displayedResult = 0
            else:
                self.displayedResult = temp

        if rMax > 0:
            result = self.results[self.displayedResult]

            resfactor = 1  # change when factor in NNfrontEnd is changed!!
            array_image = self.getCut([round(result[3] / resfactor) - 80, round(result[3] / resfactor) + 80,
                                       round(result[2] / resfactor) - 80, round(result[2] / resfactor) + 80])

            self.resultImage = array_image
        else:
            self.resultImage = NONE

        return self.displayedResult, rMax

    def getCut(self, Coords):
        """
        Checks if input Coordinates ('Coords') are within planImage limits and returns planImage cut.
        :param Coords: Upper left and lower right corner of a rectangle in canvas coordinates (User selection).
        :return: planImage cut
        """
        xy = [0, 0, 0, 0]  # [y0, y1, x0, x1]

        n, m = self.planImage.shape
        xyMax = [n, n, m, m]

        for n in range(4):
            if 0 < Coords[n] < xyMax[n]:
                xy[n] = Coords[n]
            elif Coords[n] > xyMax[n]:
                xy[n] = xyMax[n]

        return self.planImage[xy[0]:xy[1], xy[2]:xy[3]]

    def modifyCom(self, comment):
        """
        Modifies entry in results item of currently displayed result which contains comment on the result
        :param comment: User input (string)
        :return:
        """
        self.results[self.displayedResult][4] = comment

    def rotateImage(self):
        """
        Rotates 'planImage' about 90 degrees and increments rotated by 1. 'rotated' flag will be needed in export
        functions.
        :return:
        """
        self.rotated += 1
        if self.rotated == 4:
            self.rotated = 0

        self.planImage = np.rot90(self.planImage)

    def showSelf(self):
        """
        Creates reference of planData in NNdipsCanvas and calls its refresh classmethod that displays all plan images.
        :return: 'planID' of displayed plan
        """

        NNdipsCanv.clearAll()
        NNdipsCanv.plan = self
        NNdipsCanv.refresh()

        return self.planID

    def showResult(self):
        """
        Displays currently selected result in designated canvas and creates crosshairs in workbench plan-canvas as well
        as a dot marking the symbol in the workbench result-canvas
        :return: resultID as string
        """
        # ==== reset canvases ====
        NNdipsCanv.canvs['wbResult'].delete("IMG")  # result image
        NNdipsCanv.canvs['wbPlan'].delete('Line')  # crosshairs

        if len(self.results) > 0:
            # ==== 160x160 image around result ====
            result = self.results[self.displayedResult]

            NNdipsCanv.canvs['wbResult'].showImg()
            NNdipsCanv.canvs['wbResult'].create_aim()
            NNdipsCanv.canvs['wbPlan'].create_crosshairs([result[2], result[3]])
        else:
            return

        return result[0] + '-' + str(result[1])


class NNdipsCanv(Canvas):
    """
    Specialized Canvas. Resizes displayed plan, when its own size is configured.
    """

    canvs = {}  # Registrar
    plan = NONE  # displayed PlanData reference

    def __init__(self, parent, name, canvType='plan', scrollable=False):
        Canvas.__init__(self, parent, highlightbackground='grey', highlightthickness=1)
        self.name = name
        self.canvImg = NONE  # resized plan image
        self.canvType = canvType  # should be either 'plan' or 'result'
        self.scrollable = scrollable
        self.xy = [[0, 0], [0, 0]]  # rectangle coordinates for zoom function
        self.zoomed = NONE  # zoomed part of plan
        NNdipsCanv.canvs[name] = self  # register self

        if scrollable:
            vsb = Scrollbar(parent, orient="vertical", command=self.yview)
            hsb = Scrollbar(parent, orient="horizontal", command=self.xview)
            self.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)
            self.grid(row=0, column=0, sticky='nsew')
            vsb.grid(row=0, column=1, sticky='nsew')
            hsb.grid(row=1, column=0, sticky='nsew')
            parent.grid_columnconfigure(0, weight=1)
            parent.grid_rowconfigure(0, weight=1)
        else:
            self.bind('<Configure>', lambda event: self.showImg())

    @classmethod
    def refresh(cls, keys=canvs.keys()):
        """
        Deletes all Canvas items in all instances of NNdipsCanvas and then creates respective image in all instances.
        :param keys: Optional argument to directly address Canvas(es).
        :return:
        """
        for key in keys:
            cls.canvs[key].delete("all")
            cls.canvs[key].showImg()

    @classmethod
    def clearAll(cls, keys=canvs.keys()):
        """
        Deletes all Canvas items in all instances of NNdipsCanvas.
        :param keys: Optional argument to directly address Canvas(es).
        :return:
        """
        for key in keys:
            cls.canvs[key].delete("all")

    def showImg(self):
        """
        Creates image with the same size as the respective Canvas and makees it visible.
        :return:
        """
        w2 = self.winfo_width()
        h2 = self.winfo_height()
        if NNdipsCanv.plan != NONE:
            original = NNdipsCanv.plan.__dict__[self.canvType + 'Image']
        else:
            original = NONE
        if w2 > 1 and h2 > 1 and original is not NONE:
            self.canvImg = Functions.resize_image(original, (w2, h2))
            self.tag_lower(self.create_image(w2 / 2, h2 / 2, anchor=CENTER,
                                             image=self.canvImg, tags="IMG"))

    def create_image(self, *args, **kw):
        """
        Overridden to add functionality for scrollable canvas. Adjusts scrollregion on image creation.
        :param args: optional arguments, cf. tk documentation
        :param kw: optional keyword arguments, cf. tk documentation
        :return:
        """
        if self.scrollable:
            img = kw['image']
            self.configure(scrollregion=(0, 0, img.width(), img.height()))
        return self._create('image', args, kw)

    def create_crosshairs(self, coordinates):
        """
        Creates crosshairs around plan coordinates (calculates canvas coordinates accordingly).
        :param coordinates: plan coordinates in px of displayed result.
        :return:
        """
        w = self.canvImg.width()
        h = self.canvImg.height()
        wCanv = self.winfo_width()
        hCanv = self.winfo_height()
        xfac = w / self.plan.planImage.shape[1]
        yfac = h / self.plan.planImage.shape[0]
        x = round(coordinates[0] * xfac + (wCanv - w) / 2)
        y = round(coordinates[1] * yfac + (hCanv - h) / 2)
        self.create_line(x, 0, x, y - round(80 * yfac), tags="Line", width=3)
        self.create_line(x, y + round(80 * yfac), x, hCanv, tags="Line", width=3)
        self.create_line(0, y, x - round(80 * xfac), y, tags="Line", width=3)
        self.create_line(x + round(80 * xfac), y, wCanv, y, tags="Line", width=3)
        self.create_rectangle(x - round(80 * xfac), y - round(80 * yfac),
                              x + round(80 * xfac), y + round(80 * yfac), tags="Line", width=3)

    def create_aim(self):
        """
        Creates red dot in the center of a Result-type canvas
        :return:
        """
        w = self.winfo_width()
        h = self.winfo_height()
        self.create_oval(w / 2 - 2, h / 2 - 2,
                         w / 2 + 2, h / 2 + 2,
                         fill="red", tags="IMG")

    def zoomImage(self, var):
        """
        Initiates zoom by binding zoom methods to canvas
        :param var: Checkbutton variable.
        :return:
        """
        self.bind("<Button-1>", lambda e: self._cb_clicked(e, var))
        self.bind("<B1-Motion>", lambda e: self._cb_currentPos(e, var))
        self.bind("<ButtonRelease-1>", lambda e: self._cb_release(e, var))

    def _cb_clicked(self, event, var):
        """
        Stores Canvas coordinates at <MouseButton-1> down event location in 'xy'.
        :param event: <MouseButton-1 down>
        :param var: Checkbutton variable.
        :return:
        """
        if var.get():
            self.xy[0] = [event.x, event.y]
            self.delete("rectangle")

    def _cb_currentPos(self, event, var):
        """
        Called when <Mouse moved> and refreshes rectangle (zoom selection).
        :param event: <Mouse moved>
        :param var: Checkbutton variable.
        :return:
        """
        if var.get():
            self.delete("rectangle")
            self.create_rectangle(self.xy[0][0], self.xy[0][1], event.x, event.y,
                                  width=2, outline='red', tags="rectangle")

    def _cb_release(self, event, var):
        """
        Stores final coordinates when Mouse button is released and opens dialog window with zoomed image from selected
        region of the canvas.
        :param event: <MouseButton-1 up>
        :param var: Checkbutton variable.
        :return:
        """
        self.xy[1] = [event.x, event.y]
        self.xy = np.sort(self.xy, axis=0)

        if abs(self.xy[1][0] - self.xy[0][0]) > 10 and abs(self.xy[1][1] - self.xy[0][1]) > 10 and var.get():

            win_cut = Toplevel()
            win_cut.title("Zoom")
            win_cut.resizable(width=False, height=False)
            win_cut.focus_set()
            position = '+0+0'
            win_cut.geometry(position)
            win_cut.bind('<FocusOut>', lambda _: self._cb_exitZoom(win_cut, var))
            win_cut.protocol("WM_DELETE_WINDOW", lambda: self._cb_exitZoom(win_cut, var))
            canvas_cut = Canvas(win_cut, width=700, height=700)

            h_image = NNdipsCanv.plan.planImage.shape[0]
            w_image = NNdipsCanv.plan.planImage.shape[1]

            dw = (self.winfo_width() - self.canvImg.width()) / 2
            dh = (self.winfo_height() - self.canvImg.height()) / 2

            x_coeff = w_image / self.canvImg.width()
            y_coeff = h_image / self.canvImg.height()

            cv_image = NNdipsCanv.plan.getCut([int((self.xy[0][1] - dh) * y_coeff),
                                               int((self.xy[1][1] - dh) * y_coeff),
                                               int((self.xy[0][0] - dw) * x_coeff),
                                               int((self.xy[1][0] - dw) * x_coeff)])

            self.zoomed = Functions.resize_image(cv_image)

            canvas_cut.create_image(350, 350, image=self.zoomed, anchor=CENTER)
            canvas_cut.pack()

        else:
            self.delete("rectangle")
            var.set(0)

    def _cb_exitZoom(self, win_cut, var):
        """
        Disables zoom functionality, destroys dialog window and resets var and 'zoomed'.
        :param win_cut: TopLevel object (dialog window).
        :param var: Checkbutton variable.
        :return:
        """
        win_cut.destroy()
        self.unbind("<Button-1>")
        self.unbind("<B1-Motion>")
        self.unbind("<ButtonRelease-1>")
        self.delete("rectangle")
        var.set(0)
        self.zoomed = NONE


class addCNNsymbol(Toplevel):
    """
    Popup window containing all tools for creating a new CNN.
    """

    check = NONE  # Registrar

    def __init__(self):
        Toplevel.__init__(self, master=GUI.data.root)
        self.title("Add CNN")
        self.resizable(width=False, height=False)
        self.config(bd=3)
        self.focus_set()
        self.protocol("WM_DELETE_WINDOW", self.callClose)
        addCNNsymbol.check = self  # register self

        self.location_bg = "./Images/Training/Background.png"
        self.location_bg_test = "./Images/Training/BackgroundTest.png"
        self.location_sym = "Load at least one symbol"
        self.location_sym_test = "Load test symbol first"
        self.tD = TrainData()
        self.advOpt = IntVar()
        self.saveDef = IntVar()
        self.symSize = 50

        # ==== Regular options ====
        Label(self, text="Symbol Image: ", anchor=E).grid(row=1, column=0, sticky='nsew', padx=5, pady=2)
        Label(self, text="Test Image: ", anchor=E).grid(row=0, column=0, sticky='nsew', padx=5, pady=2)

        self.locLabel_sym = Label(self, text=self.location_sym, anchor=E, width=30, relief=GROOVE, bg='white')
        self.locLabel_sym.grid(row=1, column=1, columnspan=2, sticky='nsew', padx=5, pady=2)
        self.locLabel_sym_test = Label(self, text=self.location_sym_test, anchor=E, width=30, relief=GROOVE, bg='white')
        self.locLabel_sym_test.grid(row=0, column=1, columnspan=2, sticky='nsew', padx=5, pady=2)

        self.symBtn = Button(self, text="Load...", command=lambda: self.loadImageLocation("sym"), state=DISABLED)
        self.symBtn.grid(row=1, column=3, sticky='nsew', padx=5, pady=2)
        btn = Button(self, text="Load...", command=lambda: self.loadTestImg())
        btn.grid(row=0, column=3, sticky='nsew', padx=5, pady=2)

        cbtn = Checkbutton(self, text="Advanced options", variable=self.advOpt,
                           command=lambda: self.advancedOptions())
        cbtn.grid(row=2, column=1, sticky=W, padx=5, pady=2)
        self.advOpt.set(0)

        # ==== Advanced options ====
        self.advEntries = {
            'roi_size': [Label(self, text="ROI size: ", anchor=E), Entry(self), 3],
            'steps': [Label(self, text="Steps: ", anchor=E), Entry(self), 4],
            'resize': [Label(self, text="Resize: ", anchor=E), Entry(self), 5],
            'stretch': [Label(self, text="Stretch: ", anchor=E), Entry(self), 6],
            'epochs': [Label(self, text="Epochs: ", anchor=E), Entry(self), 7],
            'filters': [Label(self, text="Filters: ", anchor=E), Entry(self), 8],
            'kernel_size': [Label(self, text="Kernel size: ", anchor=E), Entry(self), 9],
            'validation_percent': [Label(self, text="Validation Part: ", anchor=E), Entry(self), 10],
            'rotation': [Label(self, text="Rotation angles: ", anchor=E), Entry(self), 11]
        }

        self.advBtns = {
            'bg': [Label(self, text="Background Image: ", anchor=E),
                   Label(self, text=self.location_bg, anchor=E, width=30, relief=GROOVE, bg='white'),
                   Button(self, text="Load...", command=lambda: self.loadImageLocation("bg")), 12],
            'bg_test': [Label(self, text="Bg-Test Image: ", anchor=E),
                        Label(self, text=self.location_bg_test, anchor=E, width=30, relief=GROOVE, bg='white'),
                        Button(self, text="Load...", command=lambda: self.loadImageLocation("bg_test")), 13],
            'default': [Button(self, text="Show example ROIs", command=lambda: self.testInputArray()),
                        Button(self, text="default", command=lambda: self.writeLabels()),
                        Checkbutton(self, text="Save as default", variable=self.saveDef), 14]
        }
        self.locLabel_bg = self.advBtns['bg'][1]
        self.locLabel_bg_test = self.advBtns['bg_test'][1]
        self.saveDef.set(0)

        # ==== Execution ====
        btn = Button(self, text="Generate TrainData", command=lambda: self.loadTrainData())
        btn.grid(row=21, column=1, sticky='nsew', padx=5, pady=2)  # todo: load advanced options
        btn = Button(self, text="Train CNN", command=lambda: self.trainCNN())
        btn.grid(row=21, column=2, sticky='nsew', padx=5, pady=2)

        self.writeLabels()

    def advancedOptions(self):
        """
        Is executed, when advanced options flag is set. Extends popup window by some advanced CNN tools.
        :return:
        """
        if self.advOpt.get() == 1:
            for key in self.advEntries.keys():
                for i, item in enumerate(self.advEntries[key][:-1]):
                    item.grid(row=self.advEntries[key][2], column=i, sticky='nsew', padx=5, pady=2)
            for key in self.advBtns.keys():
                for i, item in enumerate(self.advBtns[key][:-1]):
                    if item is not NONE:
                        item.grid(row=self.advBtns[key][-1], column=i, sticky='nsew', padx=5, pady=2)
        else:
            for key in self.advEntries.keys():
                for item in self.advEntries[key][:-1]:
                    item.grid_remove()
            for key in self.advBtns.keys():
                for item in self.advBtns[key][:-1]:
                    if item is not NONE:
                        item.grid_remove()

    def writeLabels(self):
        """
        Reads attributes from 'TrainSetup' class and transfers attributes to the respective Entry.
        :return:
        """
        for key in self.advEntries.keys():
            entr = self.advEntries[key][1]
            entr.delete(0, END)
            if type(self.tD.setup.__dict__[key]) is list:
                string = str(self.tD.setup.__dict__[key])[1:-1]
            else:
                string = str(self.tD.setup.__dict__[key])
            entr.insert(0, string)

    @classmethod
    def initialize(cls):
        """
        Checks if there is already an instance of addCNNsymbol. If not it creates an instance, otherwise it focuses
        the existing instance.
        :return:
        """
        if cls.check is NONE:
            addCNNsymbol()
        else:
            cls.callFocus(cls.check)

    def callFocus(self):
        """
        Sets focus to addCNNsymbol popup window.
        :return:
        """
        self.focus_force()
        self.bell()

    def callClose(self):
        """
        Resets class attribute and destroys self.
        :return:
        """
        addCNNsymbol.check = NONE
        self.destroy()

    def testInputArray(self):
        """
        Tests generated output. Only for debugging.
        :return:
        """
        size = self.tD.setup.roi_size[0]
        for i in range(20):
            win = self.tD.num.testInput(size)
            GUI.data.root.update()
            input('press key...')
            win.destroy()

        for i in range(5):
            win = self.tD.one.testInput(size)
            GUI.data.root.update()
            input('press key...')
            win.destroy()

        for i in range(5):
            win = self.tD.two.testInput(size)
            GUI.data.root.update()
            input('press key...')
            win.destroy()

    def loadTestImg(self):
        """
        Opens file dialog and sets chosen image as test symbol and sets the symbols size as default for the
        training images. Chosen image should be a borderless cutout from a plan.
        :return:
        """
        attr = 'sym_test'
        fTypes = [("supported files", ("*.tif", "*.jpg", "*.png")), ("tif files", "*.tif"),
                  ("jpeg files", "*.jpg"), ("png files", "*.png")]
        folder = filedialog.askopenfilenames(title='Pick one or more files', initialdir=str(os.getcwd()),
                                             filetypes=fTypes, parent=self)
        self.location_sym_test = folder[0]
        self.locLabel_sym_test.config(text=folder[0])

        # ==== get image size and dpi ====
        imgT = Image.open(folder[0])
        w, h = imgT.size
        # dpi = imgT.info['dpi'][0].numerator
        imgT.close()
        self.symSize = max(w, h) * .5
        self.tD.get_sym(folder, self.symSize, attr)
        self.symBtn.config(state=NORMAL)
        self.focus_force()

    def loadImageLocation(self, attr):
        """
        Opens file dialog and stores chosen image(s) path to the respective attribute.
        :param attr: Attribute name as string
        :return:
        """
        fTypes = [("supported files", ("*.tif", "*.jpg", "*.png")), ("tif files", "*.tif"),
                  ("jpeg files", "*.jpg"), ("png files", "*.png")]
        folder = filedialog.askopenfilenames(title='Pick one or more files', initialdir=str(os.getcwd()),
                                             filetypes=fTypes, parent=self)
        self.__dict__['location_' + attr] = folder[0]
        self.__dict__['locLabel_' + attr].config(text=folder[0])
        if attr not in ['bg', 'bg_test']:
            self.tD.get_sym(folder, self.symSize, attr)
        self.focus_force()

    def loadTrainData(self):
        """
        Reads Entries and stores date in TrainSetup and then starts generation process.
        :return:
        """
        entryKeys = ['resize', 'stretch', 'validation_percent']
        for key in self.advEntries.keys():
            entryStr = self.advEntries[key][1].get()
            entryList = entryStr.split(', ')
            if key in entryKeys:
                self.tD.setup.__dict__[key] = [*map(float, entryList)]
            else:
                self.tD.setup.__dict__[key] = [*map(int, entryList)]

        if self.saveDef.get():
            self.tD.setup.setStd()

        pBar = progressWindow(2, 'Creating background image ROIs')
        self.tD.create_bg(self.location_bg, pBar)
        self.tD.create_bg(self.location_bg_test, pBar, 'bg_test')
        pBar.destroy()
        self.tD.generateData()

        print('train: ', round(len(self.tD.bg) * (1 - self.tD.setup.validation_percent[0])))
        print('val: ', round(len(self.tD.bg) * self.tD.setup.validation_percent[0]))
        print('test: ', len(self.tD.bg_test))

    def trainCNN(self):
        """
        Adds new SymbolID to 'symDirs' and updates ListBoxes and initializes CNN training.
        :return:
        """
        new_sym = 'S001'
        for sym in GUI.data.symDirs:
            new_sym = Functions.countID(sym)
            if new_sym not in GUI.data.symDirs:
                self.tD.create_sym_ico(new_sym)
                GUI.data.symDirs.append(new_sym)
                GUI.data.ico.renewSymIco(GUI.data.symDirs)
                ListBox.objs['wbResult'].addSymbols()
                ListBox.objs['exSymbol'].addSymbols()  # Update Export tab
                break

        self.tD.setup.setStd("CNNs/" + new_sym + "/config.cnn")
        self.tD.train_CNN_num(new_sym)
        self.tD.train_CNN_one(new_sym)
        self.tD.train_CNN_two(new_sym)


class popupWindow(Toplevel):
    """
    Creates empty popup window at the center of the screen that closes when out of focus.
    """
    def __init__(self, title):
        Toplevel.__init__(self, master=GUI.data.root)
        self.title(title)
        self.resizable(width=False, height=False)
        self.config(bd=3)
        self.focus_set()
        self.protocol("WM_DELETE_WINDOW", self.callClose)
        GUI.data.root.eval('tk::PlaceWindow %s center' % self.winfo_toplevel())  # Helper Function to center window
        self.bind('<FocusOut>', lambda event: self.destroy())
        self.iconbitmap(r'.\Images\Icons\TUM.ico')

    def callClose(self):
        self.destroy()


class progressWindow(popupWindow):
    """
    Popup window with progress bar.
    """
    def __init__(self, overall=1, title='Loading...'):
        popupWindow.__init__(self, title)
        self.unbind('<FocusOut>')
        self.bind('<FocusOut>', lambda event: self.focus_force())
        self.overall = overall
        self.overLabel = Label(self, text='Overall progress')
        self.overBar = ttk.Progressbar(self, orient="horizontal", length=400, mode="determinate",
                                       value=0, maximum=100*self.overall)
        if overall > 1:
            self.overLabel.pack()
            self.overBar.pack()

        self.progLabel = Label(self)
        self.progLabel.pack()
        self.bar = ttk.Progressbar(self, orient="horizontal", length=400, mode="determinate", value=0)
        self.bar.pack()

    def callClose(self):
        pass


class AboutBox(popupWindow):
    """
    Popup window containing developer note.
    """
    def __init__(self):
        Classes.popupWindow.__init__(self, "About")
        self.aboutEntry = Text(self, height=13, width=45, spacing2=2)
        self.aboutEntry.insert(END, "This software was designed and developed by:\n"
                                    "Deian Stoitchkov,\n"
                                    "Peer Breier and\n"
                                    "Martin Slepicka\n"
                                    "at the Technische Universität München (TUM).\n\n"
                                    "The supervisor from TUM was:\n"
                                    "M.Sc. Simon Vilgertshofer.\n\n"
                                    "NNdips (Neural Network detection and\n"
                                    "interpretation of plan symbols) 2018\n"
                                    "Thank you for using NNDips!")
        self.aboutEntry.grid(row=1, column=1, rowspan=2, sticky='nsew')

        self.aboutOk = Button(self, text="OK", width=20, command=self.destroy)
        self.aboutOk.grid(row=3, column=1)


class ListBox(ttk.Treeview):
    """
    Defines ListBox with vertical scrollbar and set to trigger method on 'Selection' event.
    checkSelection method is supposed to be overridden.
    """

    objs = {}  # Registrar

    def __init__(self, parent, col, name, **kwargs):
        ttk.Treeview.__init__(self, parent, **kwargs)
        ListBox.objs[name] = self  # register self

        self.configure(columns=col[0])
        for c, w in zip(col[0], col[1]):
            self.heading(c, text=c.title(), anchor='w')
            self.column(c, width=w)
        vsb = Scrollbar(parent, orient="vertical", command=self.yview)
        self.configure(yscrollcommand=vsb.set)
        self.grid(row=0, column=0, sticky='nsew')
        vsb.grid(row=0, column=1, sticky='nsew')
        parent.grid_columnconfigure(0, weight=1)
        parent.grid_rowconfigure(0, weight=1)
        self.bind("<<TreeviewSelect>>", lambda event: self.checkSelection())

    def checkSelection(self):
        pass


# ================= Tab 1 - Upload ===============
class uploadImage(popupWindow):
    """
    Popup window with buttons for File-Upload or Directory-Upload.
    """
    def __init__(self):
        popupWindow.__init__(self, "Upload options")
        upFile = Button(self, text="Upload file", width=20, command=lambda: GUI.data.addPlan('f'))
        upDir = Button(self, text="Upload directory", width=20, command=lambda: GUI.data.addPlan('d'))
        upFile.pack(padx=2, pady=2)
        upDir.pack(padx=2, pady=2)


class UploadTools(Frame):
    """
    Container for Upload frame button elements and plan counter.
    * 'cm' displays current/maximum plan number
    * widgets are framed by a grey 1 px wide line
    """

    obj = NONE  # Registrar

    def __init__(self, parent):
        Frame.__init__(self, parent, highlightbackground='grey', highlightthickness=1, bd=4)
        self.pack(side=TOP)

        if UploadTools.obj is not NONE:
            UploadTools.obj.destroy()
        UploadTools.obj = self  # register self
        var = tk.IntVar()
        self.widgets = {
            'upBtn': tk.Button(self, text='Upload Plans', padx=20,
                               pady=14, command=lambda: uploadImage(), bg='gainsboro'),
            'leftArr': tk.Button(self, height=GUI.data.btn_size, width=GUI.data.btn_size,
                                 image=GUI.data.ico.arrowLeft, command=lambda: GUI.data.changePlan(-1)),
            'cm': tk.Label(self, text='Plan\n' + '0/' + str(len(GUI.data.planList)), width=7),
            'rightArr': tk.Button(self, height=GUI.data.btn_size, width=GUI.data.btn_size,
                                  image=GUI.data.ico.arrowRight, command=lambda: GUI.data.changePlan(1)),
            'zoom': tk.Checkbutton(self, image=GUI.data.ico.zoomToFit, variable=var, indicatoron=0,
                                   command=lambda: NNdipsCanv.canvs['upPlan'].zoomImage(var)),
            'del': tk.Button(self, text='Delete Plan', pady=14, command=lambda: GUI.data.deletePlan(),
                             bg='gainsboro'),
            'rot': tk.Button(self, text='Rotate left', padx=20,
                             pady=14, command=lambda: GUI.data.rotatePlan(), bg='gainsboro')
        }
        for key in ['upBtn', 'leftArr', 'cm', 'rightArr', 'zoom', 'del', 'rot']:
            self.widgets[key].pack(side=tk.LEFT, padx=20)

    def countmodule(self, current, pMax):
        """
        Assigns new values to plan counter
        :param current: Currently displayed plan (cf. Application attibute 'displayedPlan').
        :param pMax: Total amount of plans.
        :return:
        """
        if pMax == 0:
            current = -1
        counter = 'Plan\n' + str(current + 1) + '/' + str(pMax)
        self.widgets['cm'].config(text=counter)


# ================= Tab 2 - Workbench ===============
class ResultTools(Frame):
    """
    Container for Workbench frame button elements and result counter.
    * 'cm' displays current/maximum result number
    * widgets are framed by a grey 1 px wide line
    """

    obj = NONE  # Registrar

    def __init__(self, parent):
        Frame.__init__(self, parent, highlightbackground='grey', highlightthickness=1, bd=4)
        self.pack(anchor=CENTER)

        if ResultTools.obj is not NONE:
            ResultTools.obj.destroy()
        ResultTools.obj = self  # register self

        var = tk.IntVar()
        self.widgets = {
            'scan': tk.Button(self, bg='red', text='Scan All Plans', pady=14, command=lambda: Scan()),
            'leftArr': tk.Button(self, height=GUI.data.btn_size, width=GUI.data.btn_size,
                                 image=GUI.data.ico.arrowLeft, command=lambda: GUI.data.updateRes(-1)),
            'cm': tk.Label(self, text='Result\n' + '0/0', width=7),
            'rightArr': tk.Button(self, height=GUI.data.btn_size, width=GUI.data.btn_size,
                                  image=GUI.data.ico.arrowRight, command=lambda: GUI.data.updateRes(1)),
            'zoom': tk.Checkbutton(self, image=GUI.data.ico.zoomToFit, variable=var, indicatoron=0,
                                   command=lambda: NNdipsCanv.canvs['wbPlan'].zoomImage(var)),
            'del': tk.Button(self, text='Delete Hit', pady=14, command=lambda: GUI.data.updateRes('del'))
        }
        for key in ['scan', 'leftArr', 'cm', 'rightArr', 'zoom', 'del']:
            self.widgets[key].pack(side=tk.LEFT, padx=20)

    def countmodule(self, current, rMax):
        """
        Assigns new values to result counter
        :param current: Currently displayed result (cf. PlanData attibute 'displayedResult').
        :param rMax: Total amount of results.
        :return:
        """
        if rMax == 0:
            current = -1
        counter = 'Result\n' + str(current + 1) + '/' + \
                  str(rMax)
        self.widgets['cm'].config(text=counter)


class Scan(popupWindow):
    """
    Popup with buttons for 'Scan selected' and 'Scan all'.
    """
    def __init__(self):
        popupWindow.__init__(self, 'Scan...')
        scSelect = Button(self, text="Scan selected", width=20,
                          command=lambda: GUI.data.scanPlan([GUI.data.planList[GUI.data.displayedPlan]]))
        scAll = Button(self, text="Scan all", width=20,
                       command=lambda: GUI.data.scanPlan(GUI.data.planList))
        scSelect.pack(padx=2, pady=2)
        scAll.pack(padx=2, pady=2)


class PlanListBox(ListBox):
    """
    Single select Listbox for uploaded plans, 'Selection' event changes the displayed/selected plan.
    """
    def __init__(self, parent, col, name):
        ListBox.__init__(self, parent, col, name, show="headings", selectmode='browse')

    def checkSelection(self):
        """
        Changes 'displayedPlan' in Application class to the plan selected in PlanListBox.
        :return:
        """
        iid = self.focus()
        if iid == '' or iid != self.selection()[-1]:
            return
        disp = [i for i, item in enumerate(GUI.data.planList) if item.planID == iid]
        if disp[0] != GUI.data.displayedPlan:
            GUI.data.displayedPlan = disp[0]
            GUI.data.updateCanv()


class ResultListBox(ListBox):
    """
    Multi select Listbox for CNN results, 'Selection' event depends on parent or child selection.
    * parent level: Plan symbol, 'Selection' sets selected Symbol as active for CNN Scan
    * child level: CNN results, 'Selection' displays selected result in workbench result-canvas (no multi selection).
    """
    def __init__(self, parent, col, name, **kwargs):
        ListBox.__init__(self, parent, col, name, **kwargs)
        self.heading('#0', text='Symbol', anchor=W)
        self.column('#0', anchor=W, width=15)
        self.addSymbols()
        self.selection_set(GUI.data.activeSym)

    def checkSelection(self):
        """
        Triggered on 'Selection' event. Checks item ID of focused item:
        * on parent level (Plan symbol) -> Sets selected symbol(s) as active symbol(s) for CNN scan.
        * on child level (CNN results) -> Displays selected result (no multi selection).
        :return:
        """
        iid = self.focus()

        if iid == '':
            self.focus(self.selection()[0])
        elif iid in GUI.data.symDirs:
            for item in self.selection():
                if item not in GUI.data.symDirs:
                    self.selection_remove(item)
            GUI.data.activeSym = self.selection()
        else:
            for selectedItem in self.selection():
                if selectedItem != iid:
                    self.selection_remove(selectedItem)

            GUI.data.activeSym = self.parent(iid)
            GUI.data.updateRes(iid)

    def addSymbols(self):
        """
        Add all symbols given by symDirs to the list (parent level).
        :return:
        """
        self.delete(*self.get_children())

        for sym, ico in zip(GUI.data.symDirs, GUI.data.ico.symIco):
            values = 0
            self.insert('', 'end', values=values, iid=sym, tag='symbol', image=ico)

    def updateSelf(self, results):
        """
        Removes all child level entries (CNN results) and adds updated results (after switching of plans or deletion)
        :param results: List of CNN results of the displayed plan
        :return:
        """
        for sym in self.get_children():
            self.delete(*self.get_children(sym))

        for r in results:
            values = ('#' + str(r[1]), r[2], r[3], r[4])
            self.insert(r[0], 'end', values=values, iid=r[0] + '-' + str(r[1]), tag='result')

        for sym in self.get_children():
            self.set(sym, 'Hits', len(self.get_children(sym)))


class ResComment(Frame):
    """
    Container for second workbench toolset, e.g. Comment button.
    """
    def __init__(self, parent):
        Frame.__init__(self, parent, highlightbackground='grey', highlightthickness=1, bd=4)
        self.pack(anchor=CENTER)

        self.commentRes = tk.Button(self, text='Comment Result', pady=14,
                                    command=lambda: CommentBox())
        self.commentRes.pack(side=tk.LEFT, padx=20)


class CommentBox(popupWindow):
    """
    Creates widgets to comment the in ResultListBox selected result, e.g. Text-Widget.
    """
    def __init__(self):
        popupWindow.__init__(self, "Comment Box")

        self.commentEntry = Text(self, height=12, width=40)
        self.commentEntry.grid(row=1, column=1, rowspan=2, sticky='nsew')

        self.saveCom = tk.Button(self, text="Save Comment", width=20,
                                 command=lambda: self.saveComment())
        self.saveCom.grid(row=1, column=2)

        self.cancelComment = Button(self, text="Cancel", width=20, command=self.destroy)
        self.cancelComment.grid(row=2, column=2)

        iid = ListBox.objs['wbResult'].focus()

        if ListBox.objs['wbResult'].tag_has('result', iid):
            comment = ListBox.objs['wbResult'].set(iid, column='Comment')
            self.commentEntry.insert(END, comment)
        else:
            self.commentEntry.insert(END, 'Select a Result to change comment')
            self.commentEntry.configure(bg='grey', state=DISABLED)
            self.saveCom.configure(bg='grey', state=DISABLED)

    def saveComment(self):
        """
        Stores string entered in Text-Widget in planData 'results' and updates the ResultListbox.
        :return:
        """
        comment = self.commentEntry.get(1.0, END)
        GUI.data.planList[GUI.data.displayedPlan].modifyCom(comment)
        iid = ListBox.objs['wbResult'].focus()

        ListBox.objs['wbResult'].set(iid, 'Comment', comment)

        self.destroy()


# ================= Tab 3 - Export =============== todo: finish Export tools and comment
class ExSymListBox(ResultListBox):
    """
    ListBox containing all available CNNs. To export respective results CNNs can be selected.
    """
    def __init__(self, parent, col, name):
        ResultListBox.__init__(self, parent, col, name)
        self.symbolExport = ()

    def checkSelection(self):
        """
        Sets an array that tells the export function, which symbols are supposed to be exported.
        Triggered on 'Selection' event.
        :return:
        """
        self.symbolExport = self.selection()

    def updateSelf(self, results):
        """
        Updates 'Hits' for all symbols to match the results of the selected plan.
        :param results: List of CNN results of the displayed plan
        :return:
        """
        for sym in self.get_children():  # sym = 'S001'
            r = [res for res in results if res[0] == sym]
            self.set(sym, 'Hits', len(r))


class ExPlanListBox(ListBox):
    """
    ListBox containing all uploaded plans. Plans that are supposed to be exported can be selected here.
    """
    def __init__(self, parent, col, name):
        ListBox.__init__(self, parent, col, name, show="headings")
        self.planExport = ()

    def checkSelection(self):  # todo: Check sent to Export
        """
        Changes 'displayedPlan' in Application class to the plan selected in the exPlanListBox.
        Send message to the export function telling which plans to export
        :return:
        """
        iid = self.focus()
        self.planExport = self.selection()
        focused = [item for item in GUI.data.planList if item.planID == iid]
        if not self.planExport:  # checks if selection is empty
            ListBox.objs['exSymbol'].updateSelf([])  # sets all Hits to 0
        else:
            ListBox.objs['exSymbol'].updateSelf(focused[0].results)


class ExTools(Frame):
    """
    Reads all scanned plans and outputs the results as pdf or txt.
    """
    obj = NONE  # Registrar

    def __init__(self, parent, **kwargs):
        Frame.__init__(self, parent, **kwargs)
        ExTools.obj = self  # register self

        self.exFormatsFrame = LabelFrame(self, text=' File options ')
        self.exFormatsFrame.place(anchor=NW, relwidth=.5, rely=.5)

        formats = [('TXT-Datei', 0),
                   ('PDF-Datei', 1),
                   ('XML-Datei', 2)]
        self.fvar = IntVar()

        for txt, val in formats:
            Radiobutton(self.exFormatsFrame, text=txt, padx=20, variable=self.fvar, value=val).pack(anchor=W)
        self.fvar.set(0)

        self.exCoordsFrame = LabelFrame(self, text=' Result options ')
        self.exCoordsFrame.place(anchor=NW, relwidth=.5, relx=.5, rely=.5)

        coords = [('Pixel [pt]', 0),
                  ('Centimeter [cm]', 1),
                  ('Inches [in]', 2)]
        self.cvar = IntVar()

        for txt, val in coords:
            Radiobutton(self.exCoordsFrame, text=txt, padx=20, variable=self.cvar, value=val).pack(anchor=W)
        self.cvar.set(0)

        self.exTextFrame = LabelFrame(self, text=' Description ')
        self.exTextFrame.place(anchor=NW, relheight=.5, relwidth=1)
        message = 'Select the options for the file type using the radiobuttons.\n' \
                  'Then click Export and select a folder.\n' \
                  'All scanned plans will be saved in this folder named like this:\n' \
                  'NNDips_Result_0i time_DAY MONTH DATE HOUR.MINUTE.SECOND YEAR.FILETYPE'

        inside = Label(self.exTextFrame, text=message, justify=LEFT)
        inside.place(anchor=NW)

        self.exBtnFrame = Frame(self, highlightbackground='grey', highlightthickness=1, bd=4)
        self.exBtnFrame.place(anchor=CENTER, relx=.5, rely=.9)

        self.expBtn = Button(self.exBtnFrame, text='Export', bg='green',
                             command=lambda: Exporter.initializeExport(), padx=20, pady=5)
        self.expBtn.pack(side=BOTTOM, fill=X)

        self.file_location = ''
        self.plan_name = ''

        self.symbol_name = ''
        self.num_hits = 0
        self.num_hits_per_symbol = 0
        self.folder = ''

    def showChoice(self):
        pass

    def exportRes(self):

        self.folder = GUI.data.select_folder
        select_flag = GUI.data.select_flag
        print('The select flag', select_flag)

        if GUI.data.plan_selected_for_export:  # checks if list is not empty implicitly
            num_res = len(GUI.data.plan_selected_for_export)
            flag = 1
        else:
            num_res = len(GUI.data.planList)  # this is working also for deleting/adding
            flag = 0

        for i in range(0, num_res):  # loop over plans
            j = i  # needed for naming because i might be overwritten by selection

            if flag == 1 and select_flag == 1:
                i = GUI.data.plan_selected_for_export[i]

            # Global input
            self.file_location = GUI.data.planList[i].fileLocation
            self.plan_name = GUI.data.planList[i].planID

            date_time = time.asctime(time.localtime(time.time()))
            date_time_windows_friendly = date_time.replace(':', '.')
            self.doc_name = 'NNDips_Result_0' + str(j + 1) + ' time_' + date_time_windows_friendly

            # ==== Check input
            extensions = [".tif", "tiff", ".jpg", "jpeg", ".png"]
            # ==== PDF
            if self.file_location[-3:].lower() == "pdf":
                self.input_specifier = 0
            else:
                self.input_specifier = 1

            self.handle_input_data()

            # ==== Check output unit
            if self.cvar.get() == 0:  # Output pixels pt
                self.scaling_factor = 1
                self.unit = 'pt'
            elif self.cvar.get() == 1:  # Output meters m
                # todo: scaling factors
                self.scaling_factor = 1 / self.dpi * 0.0254
                self.unit = 'm'
            elif self.cvar.get() == 2:  # Output inches inch
                # Idea: 1 Pixel means 1 dot
                # 200 dpi means 200 pixels make 1 inch
                self.scaling_factor = 1 / self.dpi
                self.unit = 'in'

            # ==== Output as PDF
            if self.fvar.get() == 1:  # pdf Output
                self.doc_name += '.pdf'
                self.calculate_xy_for_output(i)
                self.write_doc.save(self.folder + '/' + self.doc_name)
                self.write_doc.close()

            # ==== Output as XML
            elif self.fvar.get() == 2:  # Export as xml
                print('XML not yet implemented - sorry')
            # ==== Output as TXT
            elif self.fvar.get() == 0:  # Export as txt
                self.doc_name += '.txt'
                print('folder', self.folder)
                path = self.folder + '/' + self.doc_name
                self.txt_file = open(path, 'w')  # write mode
                self.calculate_xy_for_output(i)
                self.txt_file.close()

    def calculate_xy_for_output(self, i):
        plan_size = GUI.data.planList[i].planImage.shape
        self.no_symbols = len(GUI.data.activeSym)

        self.num_hits = len(GUI.data.planList[i].results)
        # todo: This gives the total amount of all symbols, not the single hits per symbol

        # loop over all symbols
        for k in range(0, self.no_symbols):
            self.symbol_name = GUI.data.activeSym[k]  # changes for every i
            self.num_hits_per_symbol = 0

            for m in range(0, self.num_hits):  # todo: Check all for loops:

                if GUI.data.planList[i].results[m][0] == self.symbol_name:
                    self.num_hits_per_symbol += 1

            for j in range(0, self.num_hits_per_symbol):
                # Check, if the plan has previously been rotated
                if GUI.data.planList[i].rotated == True:  # todo: rewrite this, rotate vertices funtion.
                    x = self.new_size[0] - (GUI.data.planList[i].results[j][3] * (self.new_size[0] / plan_size[0]))
                    y = GUI.data.planList[i].results[j][2] * (self.new_size[1] / plan_size[1])
                else:
                    x = GUI.data.planList[i].results[j][2] * (self.new_size[0] / plan_size[1])
                    y = GUI.data.planList[i].results[j][3] * (self.new_size[1] / plan_size[0])
                # label
                self.plan_ID = GUI.data.planList[i].results[j][1]
                comment = GUI.data.planList[i].results[j][4]
                x_scaled = x * self.scaling_factor
                y_scaled = y * self.scaling_factor

                self.label = self.plan_name + ' ' + self.symbol_name + ' ' + str(self.plan_ID) + ' ' +\
                             str(round(x_scaled, 3)) + ' ' +\
                             self.unit + ' ' + str(round(y_scaled, 3)) + ' ' + self.unit + ' ' + str(comment) + ' '

                if self.fvar.get() == 1:  # pdf Ouput
                    self.write_doc[0].addTextAnnot(fitz.Point(x, y), self.label)

                elif self.fvar.get() == 0:  # txt Ouput
                    output_text = self.label + '\n'
                    self.txt_file.writelines(output_text)

    def handle_input_data(self):
        if self.input_specifier == 0:
            # todo: Is DPI always 200 for PDF?
            self.dpi = 200
            self.write_doc = fitz.open()
            read_doc = fitz.open(self.file_location)  # pdf in same folder as Main so far
            self.write_doc.insertPDF(read_doc)
            page = self.write_doc.loadPage(0)
            temp = page.bound()
            self.new_size = [temp.width, temp.height]
            read_doc.close()

        else:
            org_image = Image.open(self.file_location)
            self.dpi = org_image.info['dpi'][0].numerator
            org_image.close()

            self.write_doc = fitz.open()
            img = fitz.open(self.file_location)
            pdfbytes = img.convertToPDF()  # make a PDF stream
            img.close()  # no longer needed
            imgPDF = fitz.open("pdf", pdfbytes)  # open stream as PDF

            self.write_doc.insertPDF(imgPDF)
            page = self.write_doc.loadPage(0)
            temp = page.bound()
            self.new_size = [temp.width, temp.height]
            imgPDF.close()


class Exporter(popupWindow):
    """
    Popup window with buttons for export selection or export all plans and all symbols
    """

    obj = NONE

    def __init__(self):
        popupWindow.__init__(self, "Export options")
        self.unbind('<FocusOut>')

        self.planID = ()
        self.file_location = ()

        self.symbolID = ()
        self.num_hits = 0
        self.num_hits_per_symbol = 0
        self.folder = 'Export/'
        self.scaling_factor = 1
        self.unit = 'pt'
        self.pVar = IntVar()
        self.rVar = IntVar()

        Label(self, text="Export to: ", anchor=E).grid(row=0, column=0, sticky='nsew', padx=5, pady=2)
        self.locLabel = Label(self, text=self.folder, anchor=E, width=30, relief=GROOVE, bg='white')
        self.locLabel.grid(row=0, column=1, columnspan=2, sticky='nsew', padx=5, pady=2)
        btn = Button(self, text="Change folder", command=lambda: self.selectDestination())
        btn.grid(row=0, column=3, sticky='nsew', padx=5, pady=2)

        cbtn = Checkbutton(self, text="Export all plans", variable=self.pVar,
                           command=lambda: self.mode())
        cbtn.grid(row=1, column=1, sticky=W, padx=5, pady=2)
        self.pVar.set(0)

        cbtn = Checkbutton(self, text="Export all results", variable=self.rVar,
                           command=lambda: self.mode())
        cbtn.grid(row=1, column=2, sticky=W, padx=5, pady=2)
        self.rVar.set(0)
        self.mode()

        Button(self, text="Export Selection",
               command=lambda: self.export()).grid(row=2, column=1, columnspan=2, sticky='nsew', padx=5, pady=2)

    @classmethod
    def initializeExport(cls):
        if cls.obj is NONE:
            Exporter()
        else:
            cls.obj.focus_force()

    def mode(self):
        # planMode
        if self.pVar.get():
            self.planID = ListBox.objs['exPlan'].get_children()
        else:
            self.planID = ListBox.objs['exPlan'].planExport

        # resultMode
        if self.rVar.get():
            self.symbolID = ListBox.objs['exSymbol'].get_children()
        else:
            self.symbolID = ListBox.objs['exSymbol'].symbolExport

    def callClose(self):
        Exporter.obj = NONE
        self.destroy()

    @staticmethod
    def _createPDF(location):
        extensions = [".tif", "tiff", ".jpg", "jpeg", ".png"]

        if location[-3:].lower() == 'pdf':
            # todo: Is DPI always 200 for PDF?
            write_doc = fitz.Document()
            read_doc = fitz.Document(location)  # pdf in same folder as Main so far
            write_doc.insertPDF(read_doc)
            read_doc.close()
            page = write_doc.loadPage(0)
            temp = page.bound()
            new_size = [temp.width, temp.height]

        elif location[-4:].lower() in extensions:
            img = fitz.Document(location)
            pdfbytes = img.convertToPDF()  # make a PDF stream
            img.close()  # no longer needed
            write_doc = fitz.Document("pdf", pdfbytes)  # open stream as PDF
            page = write_doc.loadPage(0)
            temp = page.bound()
            new_size = [temp.width, temp.height]
        else:
            print('Could not read input data!')
            return [], []

        return write_doc, new_size

    def _createTXT(self, path, plan):
        path += '.txt'
        write_doc = open(path, 'w')
        write_doc.write('Plan ID = ' + plan.planID + '\n')
        write_doc.write('Filename = ' + plan.fileLocation + '\n')
        write_doc.write('Image dpi = ' + str(plan.orgDpi) + '\n')
        write_doc.write('Symbol ID(s) = ' + str(self.symbolID)[1:-1] + '\n')
        write_doc.write('Found symbols (total) = ' + str(len(plan.results)) + '\n')
        write_doc.write('\n')

        return write_doc, 0

    @staticmethod
    def calculateCoordinates(ox, oy, x, y, rot):
        if rot == 0:
            newX, newY = x, y
        elif rot == 1:
            newX = oy - y
            newY = x
        elif rot == 2:
            newX = ox - x
            newY = oy - y
        else:
            newX = y
            newY = ox - x
        return newX, newY

    def export(self):
        fvar = ExTools.obj.fvar.get()
        cvar = ExTools.obj.cvar.get()

        for pId in self.planID:
            plan = [item for item in GUI.data.planList if item.planID == pId][0]
            fileLocation = plan.fileLocation
            filename = fileLocation.split('/')
            filename = filename[-1].split('.')[0]

            dTime = time.asctime(time.localtime(time.time()))
            dTime = dTime.replace(':', '.')
            path = self.folder + 'NNdips_' + filename + '_' + dTime

            if fvar == 1:
                file, size = self._createPDF(fileLocation)
            elif fvar == 0:
                file, size = self._createTXT(path, plan)
            else:
                print('No other options available yet, sorry!')
                return

            if cvar == 0:  # Output pixels pt
                scaling_factor = plan.orgDpi / 200
                unit = 'pt'
            elif cvar == 1:  # Output meters m
                # todo: scaling factors
                scaling_factor = 2.54 / 200
                unit = 'cm'
            else:  # Output inches inch
                # Idea: 1 Pixel means 1 dot
                # 200 dpi means 200 pixels make 1 inch
                scaling_factor = 1 / 200
                unit = 'in'

            oy, ox = plan.planImage.shape

            for sId in self.symbolID:
                if fvar == 0:
                    file.write('Symbol = ' + sId + '\n')

                parRes = [res for res in plan.results if res[0] == sId]

                for r in parRes:
                    # r[2] is x-coordinate of planImage
                    # r[3] is y-coordinate of planImage

                    x, y = self.calculateCoordinates(ox, oy, r[2], r[3], plan.rotated)

                    x_scaled = round(x * scaling_factor, 3)
                    y_scaled = round(y * scaling_factor, 3)

                    label = '#' + str(r[1]) + ' ' + str(x_scaled) + unit + ' ' +\
                            str(y_scaled) + unit + ' ' + str(r[4])

                    if fvar == 0:
                        file.write(label + '\n')
                    elif fvar == 1 and plan.rotated % 2 == 0:
                        file[0].addTextAnnot(fitz.Point(x * size[0] / ox, y * size[1] / oy), sId + ' ' + label)
                    elif fvar == 1 and plan.rotated % 2 == 1:
                        file[0].addTextAnnot(fitz.Point(x * size[0] / oy, y * size[1] / ox), sId + ' ' + label)

            if fvar == 0:
                file.close()
            elif fvar == 1:
                file.save(path + '.pdf')
                file.close()

        self.destroy()

    def selectDestination(self):
        f = filedialog.askdirectory(title='Select a folder to save to', parent=self,
                                    initialdir=str(os.getcwd()))
        if f:  # checks if f is empty
            self.folder = f
            self.locLabel.config(text=self.folder)
